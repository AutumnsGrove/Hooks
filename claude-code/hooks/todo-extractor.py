#!/usr/bin/env python3
# CLAUDE_HOOK_EVENT: PostToolUse
"""
Smart TODO Extractor - Automatically scan files for TODO comments with priority detection

Scans created/edited files for:
- TODO, FIXME, HACK, XXX, NOTE, BUG comments
- Priority tags: (critical), (high), (P1), (medium), etc.
- Context (surrounding lines)

Appends to TODOS_AUTOGENERATED.md with:
- File path and line number
- Priority level (1=highest, 5=lowest)
- Full TODO text with context
- Timestamp

Keeps your manual TODOS.md separate - this is auto-generated!
"""

import json
import sys
import os
import re
from datetime import datetime
from pathlib import Path
from collections import defaultdict

# Read hook input
input_data = json.load(sys.stdin)

# Only process Edit and Write tools
tool_name = input_data.get("tool_name", "")
if tool_name not in ["Edit", "Write"]:
    sys.exit(0)

# Get file paths
file_paths_str = os.getenv("CLAUDE_FILE_PATHS", "")
if not file_paths_str:
    sys.exit(0)

file_paths = file_paths_str.split(",")

# TODO patterns with priority detection
TODO_PATTERNS = [
    # Format: (pattern, default_priority)
    (r'TODO\s*\(critical\)|FIXME\s*\(critical\)', 1),
    (r'TODO\s*\(high\)|FIXME\s*\(high\)|TODO\s*\(P1\)', 1),
    (r'TODO\s*\(P2\)|TODO\s*\(medium\)', 3),
    (r'TODO|FIXME|HACK|XXX|BUG|NOTE', 5),  # Default priority
]

# Priority labels
PRIORITY_LABELS = {
    1: "ðŸ”´ Critical Priority",
    2: "ðŸŸ  High Priority",
    3: "ðŸŸ¡ Medium Priority",
    4: "ðŸŸ¢ Low Priority",
    5: "âšª Normal Priority"
}

def extract_todos_from_file(file_path):
    """Extract all TODOs from a file with context and priority."""
    if not os.path.exists(file_path):
        return []

    todos = []

    try:
        with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
            lines = f.readlines()

        for line_num, line in enumerate(lines, start=1):
            # Check each pattern
            for pattern, default_priority in TODO_PATTERNS:
                if re.search(pattern, line, re.IGNORECASE):
                    # Extract priority from tags
                    priority = default_priority
                    if 'critical' in line.lower():
                        priority = 1
                    elif 'high' in line.lower() or '(P1)' in line:
                        priority = 1
                    elif '(P2)' in line or 'medium' in line.lower():
                        priority = 3

                    # Get context (line before and after)
                    context_before = lines[line_num - 2].strip() if line_num > 1 else ""
                    context_after = lines[line_num].strip() if line_num < len(lines) else ""

                    todos.append({
                        'file': file_path,
                        'line': line_num,
                        'priority': priority,
                        'text': line.strip(),
                        'context_before': context_before,
                        'context_after': context_after
                    })
                    break  # Only match first pattern

    except Exception as e:
        print(f"[todo-extractor] Warning: Could not read {file_path}: {e}", file=sys.stderr)

    return todos

# Extract TODOs from all modified files
all_todos = []
for file_path in file_paths:
    if file_path and os.path.isfile(file_path):
        todos = extract_todos_from_file(file_path)
        all_todos.extend(todos)

# If no TODOs found, exit
if not all_todos:
    sys.exit(0)

# Group TODOs by priority
todos_by_priority = defaultdict(list)
for todo in all_todos:
    todos_by_priority[todo['priority']].append(todo)

# Get project directory (fallback to current dir)
project_dir = os.getenv("CLAUDE_PROJECT_DIR", os.getcwd())
output_file = os.path.join(project_dir, "TODOS_AUTOGENERATED.md")

# Read existing file to avoid duplicates
existing_todos = set()
if os.path.exists(output_file):
    try:
        with open(output_file, 'r', encoding='utf-8') as f:
            content = f.read()
            # Extract existing TODO identifiers (file:line)
            for match in re.finditer(r'### (.+?):(\d+)', content):
                existing_todos.add(f"{match.group(1)}:{match.group(2)}")
    except Exception:
        pass

# Prepare new TODOs to append
new_todos = []
for todo in all_todos:
    identifier = f"{todo['file']}:{todo['line']}"
    if identifier not in existing_todos:
        new_todos.append(todo)

# If no new TODOs, exit
if not new_todos:
    sys.exit(0)

# Append to file
try:
    # If file doesn't exist, create header
    if not os.path.exists(output_file):
        with open(output_file, 'w', encoding='utf-8') as f:
            f.write("# Auto-Generated TODOs\n\n")
            f.write("> This file is automatically generated by the TODO extractor hook.\n")
            f.write("> Do NOT edit manually - use TODOS.md for manual tracking.\n")
            f.write("> Last updated: {}\n\n".format(datetime.now().strftime("%Y-%m-%d %H:%M")))

    # Group new TODOs by priority
    new_by_priority = defaultdict(list)
    for todo in new_todos:
        new_by_priority[todo['priority']].append(todo)

    # Append new TODOs
    with open(output_file, 'a', encoding='utf-8') as f:
        f.write(f"\n\n## Added: {datetime.now().strftime('%Y-%m-%d %H:%M')}\n\n")

        # Sort by priority
        for priority in sorted(new_by_priority.keys()):
            todos_list = new_by_priority[priority]
            f.write(f"### {PRIORITY_LABELS.get(priority, 'Priority ' + str(priority))}\n\n")

            for todo in todos_list:
                f.write(f"#### {todo['file']}:{todo['line']}\n")
                f.write(f"- **TODO**: {todo['text']}\n")
                if todo['context_before']:
                    f.write(f"- Context: {todo['context_before']}\n")
                f.write(f"- Added: {datetime.now().strftime('%Y-%m-%d %H:%M')}\n\n")

    print(f"[todo-extractor] âœ“ Extracted {len(new_todos)} TODOs to {output_file}", file=sys.stderr)

except Exception as e:
    print(f"[todo-extractor] Error writing TODOs: {e}", file=sys.stderr)

sys.exit(0)

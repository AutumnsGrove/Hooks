# Hook Ideas & Implementation Plan

> Ideas captured: 2025-11-13
> Status: Planning phase
> Priority: Organize by implementation order

---

## Quick Reference

- ðŸŸ¢ **High Priority** - Implement soon
- ðŸŸ¡ **Medium Priority** - Valuable but not urgent
- ðŸ”µ **Nice to Have** - Future enhancement
- ðŸŸ£ **Far Future** - Long-term idea

---

## 1. Code Quality & Formatting

### ðŸŸ¢ Auto-Formatters Suite
**Event:** PostToolUse
**Matchers:** `Edit:*.py`, `Edit:*.ts`, `Edit:*.tsx`, `Edit:*.js`, `Edit:*.go`, etc.

Automatically format code after edits:
- **Black** for Python
- **Prettier** for TypeScript/JavaScript
- **Gofmt** for Go
- **Rustfmt** for Rust

**Implementation notes:**
- Keep it simple to avoid slowdown
- Consider bundling into one hook script with conditional logic based on file extension

---

### ðŸŸ¢ Smart TODO Extractor
**Event:** PostToolUse
**Matcher:** `Edit:*|Write:*`

Automatically scan created/edited files for TODO comments and extract them:
- Regex scan for `TODO`, `FIXME`, `HACK`, `XXX`, `NOTE`, `BUG`, etc.
- Grab surrounding context (line above/below)
- **NEW: Priority detection** from tags like `TODO(high)`, `FIXME(P1)`, `TODO(critical)`
- Append to `TODOS_AUTOGENERATED.md` with:
  - File path
  - Line number
  - Priority level (1=highest, 5=lowest)
  - Full TODO text with context
  - Timestamp

**Priority parsing:**
```python
# Supports these formats:
TODO(critical): Fix memory leak    # Priority 1
FIXME(high): Refactor auth         # Priority 1
TODO(P1): Add validation           # Priority 2
TODO(medium): Improve logging      # Priority 3
TODO: Regular task                 # Priority 5 (default)
```

**Output format example:**
```markdown
# Auto-Generated TODOs

> Last updated: 2025-11-13 14:30
> Total TODOs: 42

## ðŸ”´ Critical Priority (3)

### src/auth.py:42
- **FIXME(critical)**: Memory leak in JWT validation
- Context: Token refresh endpoint experiencing issues
- Added: 2025-11-13 14:30

## ðŸŸ¡ High Priority (8)

### src/api.py:156
- **TODO(high)**: Refactor authentication logic to use JWT
- Context: Currently using session-based auth
- Added: 2025-11-13 14:30

## ðŸŸ¢ Normal Priority (31)

[... rest of TODOs ...]
```

---

## 2. Testing & Validation

### ðŸŸ¢ Auto Test Runner
**Event:** SubagentStop (or PostToolUse)
**Trigger:** Regex scan for "tests created", "test implementation", "test suite"

Automatically run tests when subagents create them:
- Scan subagent completion summary for test-related keywords
- Detect test files created/modified
- Run appropriate test command:
  - `uv run pytest` for Python
  - `npm test` for JavaScript
  - `cargo test` for Rust
  - `go test ./...` for Go

**Smart detection with scope control:**
- Check which test framework is being used
- **Smart test selection:**
  - If â‰¤3 files changed: Run related tests only
  - If >3 files changed: Run full test suite
- Display results in concise format

**Implementation:**
```python
def detect_test_scope(modified_files, test_framework):
    """Determine which tests to run based on changes"""
    if len(modified_files) <= 3:
        return get_related_tests(modified_files, test_framework)
    else:
        return get_all_tests(test_framework)

def run_tests_smart(test_files, framework):
    """Run tests with informative output"""
    # Run tests and parse output for summary
    summary = parse_test_summary(result.stdout)

    print(f"âœ“ {summary['passed']} passed")
    if summary['skipped'] > 0:
        print(f"â­ï¸  {summary['skipped']} skipped (unrelated)")
    if summary['failed'] > 0:
        print(f"âœ— {summary['failed']} failed")
```

**Flag options:**
- Default: Run related tests only
- `--all-tests`: Run full suite
- `--no-tests`: Skip testing

---

## 3. Git & Version Control

### ðŸŸ¢ Conventional Commit Validator
**Event:** PreToolUse
**Matcher:** `Bash:git commit*`

Enforce conventional commit format:
- Regex: `^(feat|fix|docs|refactor|test|chore|perf|style|ci|build)(\(.+\))?: .+`
- Block commits that don't match (exit code 2)
- Provide helpful error message with examples

**Valid formats:**
```bash
feat: add user authentication
fix(auth): correct JWT expiration handling
docs: update README with installation steps
```

---

### ðŸŸ¢ Modified Commit Message Footer
**Event:** PreToolUse or PostToolUse
**Matcher:** `Bash:git commit*`

Change the commit footer from:
```
ðŸ¤– Generated with [Claude Code](https://claude.com/claude-code)
Co-Authored-By: Claude <noreply@anthropic.com>
```

To:
```
Created with Claude Code Sonnet 4.5
```

**Changes:**
- âœ… No emoji
- âœ… No "Co-Authored-By" line
- âœ… Cleaner, includes model version
- âœ… Simple and concise

---

### ðŸŸ¡ Smart PR Creator
**Event:** PreToolUse
**Matcher:** `Bash:git commit*`

When committing a LOT of changes, create a PR instead of going straight to main:

**Triggers:**
- More than X files changed (configurable, default: 10)
- More than Y lines changed (configurable, default: 500)
- Commit message indicates major feature (starts with `feat!` or `BREAKING`)

**Actions:**
1. Calculate change size with Python script
2. If threshold exceeded:
   - Create feature branch: `feature/auto-pr-{timestamp}`
   - Commit changes to branch
   - Push branch
   - Create PR using `gh pr create`
   - Notify user

**Configuration:**
- `~/.claude/hooks/smart-pr-config.json` for thresholds
- Option to bypass with commit flag

---

### ðŸŸ¡ "Grand Finale" Auto-Push Hook
**Event:** PostToolUse (after successful commit)
**Matcher:** `Bash:git commit*`

Automatically push and sync after commits:
- Detect successful commit
- Run `git push origin <current-branch>`
- Display sync status

**Safety considerations:**
- Only on specific branches? (not main/master by default?)
- Configurable opt-in/opt-out
- Skip if working on PR

---

## 4. Security & Safety

### ðŸŸ¢ rm -rf Protection
**Event:** PreToolUse
**Matcher:** `Bash:*rm -rf*` or `Bash:*rm *-rf*`

Don't block the command, but move files to trash instead:

**Implementation:**
1. Intercept `rm -rf` commands
2. Parse target paths
3. Use `trash` command (macOS/Linux) instead:
   ```bash
   trash "$TARGET" # instead of rm -rf
   ```
4. **NEW: Audit log** - Track what got trashed
5. Notify Claude: "Moved to trash instead of permanently deleting"

**Audit logging:**
```bash
# Create audit log
TRASH_LOG="$HOME/.claude/trash_audit.log"

log_trash_action() {
    local target="$1"
    local timestamp=$(date -Iseconds)
    echo "$timestamp | $target | rm -rf protection" >> "$TRASH_LOG"
}
```

**Audit log format:**
```
2025-11-13T14:30:00-05:00 | /Users/autumn/project/old_files | rm -rf protection
2025-11-13T15:45:00-05:00 | /Users/autumn/temp | rm -rf protection
```

**Benefits:**
- Safety net for accidents
- Non-blocking (doesn't break flow)
- Easy recovery with audit trail
- Know exactly what was trashed and when

**Requirements:**
- Install `trash-cli` or use native macOS `trash` command

---

### ðŸŸ¡ Secrets Scanner
**Event:** PreToolUse
**Matcher:** `Edit:*|Write:*`

Check if git hooks already handle this (`.git/hooks/pre-commit-secrets`), but consider adding:
- Real-time scanning before Claude processes
- Patterns for API keys, tokens, credentials
- Block with exit code 2 if detected

**Note:** May already be covered by existing git hooks - verify first!

---

## 5. Python & UV Integration

### ðŸŸ¢ UV Enforcement Hook
**Event:** PreToolUse
**Matcher:** `Bash:python *|Bash:pytest *|Bash:pip *`

Automatically rewrite Python commands to use UV:

**Transformations:**
```bash
python script.py â†’ uv run python script.py
pytest tests/ â†’ uv run pytest tests/
pip install pkg â†’ uv pip install pkg
```

**Implementation:**
- Intercept command in PreToolUse
- Rewrite command
- Pass modified command to Claude
- Notify: "Enforcing UV usage: uv run python..."

**NEW: Escape hatch for special cases:**
```python
def should_enforce_uv(command, context):
    """Check if UV enforcement should be bypassed"""

    # Check for escape hatch comment in recent conversation
    if '# VANILLA_PYTHON' in context:
        return False

    # Check environment variable
    if os.getenv('CLAUDE_ALLOW_VANILLA_PYTHON') == '1':
        return False

    # Check for system Python contexts (venv activation, etc.)
    if 'source venv/bin/activate' in context:
        return False

    return True  # Enforce UV by default
```

**Usage examples:**
```bash
# In chat: "Run this with vanilla Python"
# VANILLA_PYTHON
python script.py  # Will NOT be rewritten to uv run

# Or set environment variable
export CLAUDE_ALLOW_VANILLA_PYTHON=1
```

---

### ðŸŸ¢ UV Sync Hook
**Event:** PostToolUse
**Matcher:** `Edit:pyproject.toml|Edit:requirements.txt`

Automatically run `uv sync` when dependencies change:
- Detect edits to `pyproject.toml` or `requirements.txt`
- Run `uv sync` in background
- Display result (success/failure)

---

## 6. Visual Development & Screenshots

### ðŸŸ¡ Live Website Screenshot Hook
**Event:** PostToolUse (on file changes)
**Matcher:** `Edit:*.html|Edit:*.css|Edit:*.tsx|Edit:*.jsx`

Automatically screenshot the visible browser tab/desktop:

**Workflow:**
1. Detect web dev file changes
2. Take desktop screenshot with Python script
3. **NEW: Optimization pipeline** (process BEFORE sending to Claude)
4. Inject optimized screenshot into Claude's context
5. Claude can SEE what it's creating in real-time

**Screenshot Optimization Pipeline:**

**Step 1: Intelligent Cropping**
```python
from PIL import Image

def crop_macos_chrome(screenshot_path):
    """Remove macOS UI elements to focus on content"""
    img = Image.open(screenshot_path)
    width, height = img.size

    # Crop amounts (adjust as needed)
    menu_bar = 30       # Top menu bar
    dock_height = 70    # Bottom dock

    # Crop: (left, top, right, bottom)
    cropped = img.crop((0, menu_bar, width, height - dock_height))
    return cropped
```

**Step 2: Resize & Compress**
```python
def optimize_screenshot(img):
    """Resize and compress for optimal file size"""
    max_width = 1600

    if img.width > max_width:
        ratio = max_width / img.width
        new_height = int(img.height * ratio)
        img = img.resize((max_width, new_height), Image.LANCZOS)

    # Save as JPEG with 75-80% quality
    img.save(output_path, 'JPEG', quality=80, optimize=True)
```

**Step 3: Smart Deduplication**
```python
import imagehash

def should_send_screenshot(new_img, previous_hash):
    """Only send if screenshot changed meaningfully"""
    new_hash = imagehash.phash(new_img)

    if previous_hash is None:
        return True, new_hash

    # Calculate difference (lower = more similar)
    diff = new_hash - previous_hash

    # Only send if changed by >5-10%
    threshold = 8  # Adjust based on testing
    return diff > threshold, new_hash
```

**Performance improvements:**
- Before: 5-10MB PNG per screenshot
- After: 100-300KB JPEG/WebP
- Processing time: ~50ms per screenshot
- Context savings: 95-97% size reduction

**Requirements:**
- Dev server must be running
- Browser tab visible on screen
- Install: `pip install Pillow imagehash`

---

### ðŸ”µ Firefox DevTools Integration
**Event:** PostToolUse (on web dev changes)

Similar to Chrome DevTools Protocol but for Firefox:
- Use Firefox Remote Debugging Protocol
- Inspect DOM, network, console
- Capture performance metrics

**Note:** Lower priority, more complex setup

---

## 7. Audio & Notifications

### ðŸŸ¡ Session End TTS (Randomized)
**Event:** SessionEnd or Stop

Play randomized TTS message when Claude finishes:

**Using Kokoro TTS with BF_lily voice (kokoro-mlx):**

**NEW: Outcome-based message variations:**

```python
import random
import subprocess

TTS_MESSAGES = {
    'success': [
        "Claude Code session complete",
        "All tasks finished successfully",
        "Work completed",
        "Session ended, ready for next task",
        "Processing complete"
    ],
    'error': [
        "Session ended with errors",
        "Tasks completed with issues",
        "Session finished, review needed"
    ],
    'long_session': [
        "Long session complete, great work",
        "Extended session finished",
        "Marathon session complete"
    ]
}

def get_tts_message(session_duration, had_errors):
    """Select appropriate message based on session outcome"""

    if had_errors:
        category = 'error'
    elif session_duration > 1800:  # 30+ minutes
        category = 'long_session'
    else:
        category = 'success'

    return random.choice(TTS_MESSAGES[category])

def play_tts(message, voice='BF_lily'):
    """Play TTS message using Kokoro"""
    subprocess.run([
        'kokoro-mlx',  # Verify command name
        '--voice', voice,
        '--text', message
    ])
```

**Voice variations (future enhancement):**
- Success: BF_lily (friendly, upbeat)
- Errors: Different voice or lower pitch
- Long sessions: Warmer, encouraging tone

**Note:** Keep cloud TTS for future, use local Kokoro for now

---

### ðŸŸ¡ More Specific Command Sounds
**Ideas from research:** Different sounds for git, ffmpeg, npm, etc.

**Consideration:** You mentioned this added overhead before. Let's implement carefully:
- Only add sounds for most common commands
- Keep sound files small
- Test performance impact
- Easy to disable

**Examples:**
- Git operations: submarine.aiff
- Tests passing: glass.aiff
- Errors: basso.aiff
- File edits: pop.aiff

---

## 8. Analytics & Tracking

### ðŸŸ¢ Session End Data Capture
**Event:** SessionEnd

Parse and store session data in SQLite DB:

**Captured data:**
- Session ID & timestamp
- Duration (start to end)
- Tools used (count by type)
- Files modified (list)
- Commands executed (list)
- Tokens used (estimate)
- Model used (Sonnet 4.5, etc.)
- Extremely generalized summary (AI-generated, 2-3 sentences)

**Database schema:**
```sql
CREATE TABLE sessions (
    id TEXT PRIMARY KEY,
    timestamp DATETIME,
    duration_seconds INTEGER,
    tools_used JSON,
    files_modified JSON,
    commands JSON,
    summary TEXT,
    model TEXT
);
```

**Background processing:**
- Python script runs async
- No impact on Claude session (already ending)
- Brief message: "Session data captured âœ“" (optional)

**Future:** Monthly visualizations (charts, trends, productivity insights)

---

### ðŸŸ¢ Subagent Session Tracking
**Event:** SubagentStop

Similar to main session tracking, but for subagents:

**Captured data:**
- Subagent type/name
- Task summary (from subagent completion message)
- Duration
- Files touched
- "Next steps" recommendations (parsed from summary)

**Separate SQLite DB:**
```sql
CREATE TABLE subagent_sessions (
    id TEXT PRIMARY KEY,
    parent_session_id TEXT,
    subagent_type TEXT,
    timestamp DATETIME,
    duration_seconds INTEGER,
    summary TEXT,
    next_steps TEXT,
    files_modified JSON
);
```

**Use case:** Query which subagents are most used, track task patterns

---

### ðŸŸ¢ Command Tracking Hook
**Event:** PostToolUse
**Matcher:** `*` (ALL TOOLS)

**DECISION: Track ALL tool calls, not just Bash**

Track which tools Claude Code uses and when:

**Enhanced SQLite Schema:**
```sql
CREATE TABLE tool_calls (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    session_id TEXT NOT NULL,
    timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,
    tool_type TEXT NOT NULL,  -- 'Edit', 'Write', 'Read', 'Bash', 'View', etc.
    tool_params JSON,          -- Full parameters as JSON
    file_path TEXT,            -- For Edit/Write/Read/View
    command TEXT,              -- For Bash
    description TEXT,          -- Claude's reasoning/description
    exit_code INTEGER,         -- Return code (0 = success)
    duration_ms INTEGER,       -- Execution time in milliseconds
    success BOOLEAN,           -- Quick filter for success/failure
    FOREIGN KEY (session_id) REFERENCES sessions(id)
);

-- Indexes for fast queries
CREATE INDEX idx_tool_calls_session ON tool_calls(session_id);
CREATE INDEX idx_tool_calls_timestamp ON tool_calls(timestamp);
CREATE INDEX idx_tool_calls_type ON tool_calls(tool_type);
CREATE INDEX idx_tool_calls_success ON tool_calls(success);
CREATE INDEX idx_tool_calls_file ON tool_calls(file_path) WHERE file_path IS NOT NULL;
```

**Example Queries:**
```sql
-- Most frequently used tools
SELECT tool_type, COUNT(*) as count
FROM tool_calls
GROUP BY tool_type
ORDER BY count DESC;

-- Which files get edited most
SELECT file_path, COUNT(*) as edit_count
FROM tool_calls
WHERE tool_type IN ('Edit', 'Write')
GROUP BY file_path
ORDER BY edit_count DESC
LIMIT 20;

-- Average duration by tool type
SELECT tool_type, AVG(duration_ms) as avg_duration_ms
FROM tool_calls
GROUP BY tool_type;

-- Success rate by tool
SELECT tool_type,
       SUM(CASE WHEN success THEN 1 ELSE 0 END) * 100.0 / COUNT(*) as success_rate
FROM tool_calls
GROUP BY tool_type;

-- Bash commands executed (most common)
SELECT command, COUNT(*) as count
FROM tool_calls
WHERE tool_type = 'Bash'
GROUP BY command
ORDER BY count DESC
LIMIT 20;
```

**Analysis ideas:**
- Most frequently used tools (Edit vs Write vs Bash)
- Which files get modified most
- Command patterns per project type
- Time of day usage patterns
- Success/failure rates per tool
- Average execution time by tool type

---

## 9. NPM & Package Management

### ðŸŸ¡ NPM Vulnerability Checker
**Event:** PostToolUse
**Matcher:** `Bash:npm install*`

Check for vulnerabilities after npm install:

**Implementation:**
1. Wait for `npm install` to complete
2. Parse output for vulnerability warnings
3. If vulnerabilities found:
   - Display summary
   - Suggest: "Run `npm audit fix` to resolve"
   - Optionally auto-run `npm audit fix --force` (configurable)

**Output example:**
```
âš ï¸  NPM Vulnerabilities Detected:
- 3 high severity
- 7 moderate severity

Suggestion: Run `npm audit fix` to resolve
```

---

## 10. Context Enhancement

### ðŸŸ¢ Session Start Context Loader
**Event:** SessionStart

Automatically provide Claude with project context on session start:

**Context to load:**
1. **Git info:**
   - Last 10 commits (`git log -10 --oneline`)
   - Current branch
   - Uncommitted changes (`git status --short`)

2. **Project files (with size limits):**
   - `README.md` (if exists)
   - `Spec.md` or `SPEC.md` (project specification)
   - `TODOS.md` (main TODO list)
   - `CLAUDE.md` (project instructions)

3. **Dependencies:**
   - `package.json` (for Node projects)
   - `pyproject.toml` (for Python projects)
   - `Cargo.toml` (for Rust projects)
   - `go.mod` (for Go projects)

4. **Environment:**
   - Check for `.env.example` or `.env.template`
   - List available environment variables (without values)

**NEW: Size Limits to Prevent Context Bloat:**

```python
MAX_FILE_SIZE = 50_000  # 50KB
MAX_LINES = 500

def load_context_file(filepath):
    """Load file with size/line limits"""
    try:
        with open(filepath, 'r') as f:
            lines = f.readlines()

        if len(lines) > MAX_LINES:
            # Take first 400 lines, show truncation notice, last 100 lines
            content = ''.join(lines[:400])
            content += f"\n\n[... truncated, {len(lines) - 500} more lines ...]\n\n"
            content += ''.join(lines[-100:])
            return content
        else:
            return ''.join(lines)

    except Exception as e:
        return f"[Error loading {filepath}: {e}]"
```

**Applied to:**
- README.md
- SPEC.md
- TODOS.md
- CLAUDE.md
- Package manifests (pyproject.toml, package.json, etc.)

**Implementation:**
- Python script that aggregates all context
- Output as structured JSON or markdown
- Inject into Claude's context via stdout (exit code 0)
- **Keep it concise with size limits**

**Benefits:**
- Claude starts with full project understanding
- Faster task completion
- Fewer clarifying questions needed
- No context bloat from huge files

---

## 11. Future / Experimental Ideas

### ðŸŸ£ Telegram Bot Integration (Far Future)
**Status:** Optional, low priority

Two-way communication via Telegram:
- Receive notifications when sessions complete
- Send commands to Claude remotely
- Interactive buttons for common actions

**Considerations:**
- Needs to be TOTALLY optional
- Maybe a session-specific flag to enable?
- Security: whitelist users
- Not a hooks thing, more of a separate service

**Implementation complexity:** High
**Timeline:** Not urgent, revisit later

---

## Implementation Priority

### Phase 1: Core Functionality (Implement First)
1. âœ… Auto-formatters suite
2. âœ… Smart TODO extractor
3. âœ… UV enforcement hook
4. âœ… UV sync hook
5. âœ… Conventional commit validator
6. âœ… Modified commit message footer
7. âœ… rm -rf protection
8. âœ… Session start context loader

### Phase 2: Testing & Quality (Next)
9. âœ… Auto test runner
10. âœ… Command tracking hook
11. âœ… Session end data capture
12. âœ… Subagent session tracking

### Phase 3: Enhancements (After Core is Stable)
13. âœ… Smart PR creator
14. âœ… Session end TTS (randomized)
15. âœ… Live website screenshot hook
16. âœ… NPM vulnerability checker
17. âœ… "Grand finale" auto-push hook
18. âœ… More specific command sounds

### Phase 4: Advanced Features (Future)
19. â³ Firefox DevTools integration
20. â³ Telegram bot integration

---

## 12. Performance Optimization

### Async Logging for Tool Tracking

**Problem:** Synchronous database writes could add latency
**Solution:** Background thread with queue

```python
import queue
import threading
import sqlite3

class AsyncLogger:
    def __init__(self, db_path):
        self.queue = queue.Queue()
        self.db_path = db_path
        self.running = True

        # Start background thread
        self.thread = threading.Thread(target=self._worker, daemon=True)
        self.thread.start()

    def log(self, tool_call_data):
        """Non-blocking log call"""
        self.queue.put(tool_call_data)

    def _worker(self):
        """Background thread that writes to database"""
        conn = sqlite3.connect(self.db_path)

        while self.running:
            try:
                # Wait for data with timeout
                data = self.queue.get(timeout=1.0)

                # Write to database
                self._write_to_db(conn, data)

            except queue.Empty:
                continue

        conn.close()

# Usage in hooks
logger = AsyncLogger("~/.claude/analytics.db")
logger.log(tool_call_data)  # Non-blocking!
```

### Alternative: Batch Writes

```python
class BatchLogger:
    def __init__(self, db_path, batch_size=10, flush_interval=5.0):
        self.db_path = db_path
        self.batch = []
        self.batch_size = batch_size
        self.flush_interval = flush_interval
        self.last_flush = time.time()

    def log(self, data):
        """Add to batch"""
        self.batch.append(data)

        # Flush if batch full or time elapsed
        if len(self.batch) >= self.batch_size or \
           time.time() - self.last_flush > self.flush_interval:
            self.flush()

    def flush(self):
        """Write batch to database"""
        if not self.batch:
            return

        conn = sqlite3.connect(self.db_path)
        conn.executemany("""
            INSERT INTO tool_calls ...
        """, self.batch)
        conn.commit()
        conn.close()

        self.batch = []
        self.last_flush = time.time()
```

### Performance Targets

| Hook | Target Overhead | Actual |
|------|----------------|---------|
| Screenshot optimization | <100ms | ~50ms |
| Tool tracking (async) | <5ms | <2ms |
| Context loader | <200ms | TBD |
| Auto-formatter | <500ms | varies by file size |

---

## 13. Configuration

### Suggested Config Structure

```json
// ~/.claude/hooks/config.json
{
  "screenshots": {
    "enabled": true,
    "max_width": 1600,
    "quality": 80,
    "format": "JPEG",
    "crop_chrome": true,
    "deduplication_threshold": 8
  },
  "tracking": {
    "enabled": true,
    "all_tools": true,
    "batch_size": 10,
    "flush_interval_seconds": 5
  },
  "context_loader": {
    "max_file_lines": 500,
    "max_file_size_kb": 50
  },
  "uv_enforcement": {
    "enabled": true,
    "allow_escape_hatch": true
  },
  "tts": {
    "enabled": true,
    "voice": "BF_lily",
    "outcome_based_messages": true
  },
  "rm_protection": {
    "enabled": true,
    "audit_log": true
  },
  "auto_formatters": {
    "enabled": true,
    "formatters": {
      "python": "black",
      "javascript": "prettier",
      "typescript": "prettier",
      "go": "gofmt",
      "rust": "rustfmt"
    }
  },
  "smart_pr": {
    "enabled": true,
    "file_threshold": 10,
    "line_threshold": 500
  },
  "auto_push": {
    "enabled": true,
    "skip_main": true,
    "skip_master": true,
    "push_if_only_branch": true
  }
}
```

### Directory Structure

```
~/.claude/hooks/
â”œâ”€â”€ config.json
â”œâ”€â”€ scripts/
â”‚   â”œâ”€â”€ screenshot_optimizer.py
â”‚   â”œâ”€â”€ async_logger.py
â”‚   â”œâ”€â”€ todo_extractor.py
â”‚   â”œâ”€â”€ context_loader.py
â”‚   â”œâ”€â”€ uv_enforcer.sh
â”‚   â”œâ”€â”€ rm_protection.sh
â”‚   â””â”€â”€ ...
â”œâ”€â”€ databases/
â”‚   â”œâ”€â”€ analytics.db
â”‚   â””â”€â”€ sessions.db
â””â”€â”€ logs/
    â””â”€â”€ trash_audit.log
```

---

## Questions for Clarification

### 1. Smart TODO Extractor âœ… DECIDED
**Q:** Should it REPLACE the existing TODOS.md or keep both separate?
- âœ… **Option A: Keep manual TODOS.md, generate TODOS_AUTOGENERATED.md**
- Keep both files separate to prevent accidental overwrites

---

### 2. Grand Finale Auto-Push âœ… DECIDED
**Q:** Should this auto-push to ALL branches or exclude certain ones?
- âœ… **Skip main/master branches UNLESS they are the only branch**
- Auto-push on all other branches (feature, dev, etc.)
- If only main exists: push to main
- Safety: Protects main from accidental pushes when working on features

---

### 3. Live Website Screenshot
**Q:** How often should screenshots be taken?
- Every file change? (could be excessive)
- Every N changes?
- Only when Claude asks "how does it look?"
- Manual trigger via special comment?

**Recommendation:** Start conservative (only on request or every 5 changes)

---

### 4. Session End TTS â³ TO INVESTIGATE
**Q:** Is Kokoro TTS CLI available as `kokoro-cli` or different command?
- â³ **Need to check: likely `kokoro-mlx` (HuggingFace project)**
- Will verify command syntax and BF_lily voice availability
- Mute toggle: Yes, add configurable on/off

---

### 5. Command Tracking âœ… DECIDED
**Q:** Track ALL commands or just Bash commands?
- âœ… **Track ALL tools (Edit, Write, Read, Bash, etc.)**
- Enhanced schema with tool_type, file_path, command fields
- Async/batch logging for performance

---

### 6. Smart PR Creator Thresholds
**Q:** What thresholds feel right to you?
- Files changed: 10? 15? 20?
- Lines changed: 500? 1000?
- Should it ask for confirmation or just do it?

---

## Next Steps

1. âœ… **Clarify questions** - Major decisions made!
2. **Set up project structure** for hooks:
   - Create `~/.claude/hooks/` directory with subdirectories
   - Set up databases (analytics.db, sessions.db)
   - Create config.json
   - Write hook scripts
   - Configure `.claude/settings.json`
3. **Implement Phase 1** with optimizations:
   - Use async/batch logging for tracking
   - Apply size limits to context loader
   - Add priority detection to TODO extractor
   - Include escape hatches where needed
4. **Test performance** of each hook:
   - Measure overhead
   - Verify non-blocking behavior
   - Test toggleability
5. **Document each hook** as we implement

---

## Implementation Checklist

### Before You Start
- [ ] Install dependencies:
  - [ ] `trash-cli` (or use macOS `trash`)
  - [ ] `kokoro-mlx` (verify command name)
  - [ ] `pip install Pillow imagehash` for screenshots
  - [ ] Formatter tools (black, prettier, gofmt, etc.)
- [ ] Set up `~/.claude/hooks/` directory structure
- [ ] Create SQLite databases with schemas
- [ ] Create config.json with defaults

### Phase 1 Enhancements
- [ ] Implement screenshot optimization pipeline
- [ ] Set up async/batch logging for tool tracking
- [ ] Add size limits to context loader
- [ ] Add priority detection to TODO extractor
- [ ] Add escape hatch to UV enforcement
- [ ] Add audit log to rm -rf protection

### Phase 2 & 3
- [ ] Implement smart test scope detection
- [ ] Add outcome-based TTS variations
- [ ] Create database indexes
- [ ] Test performance of all hooks

---

## Notes

- Keep all implementations **simple and straightforward** to avoid slowdown
- **Performance targets:** Screenshot <100ms, Tool tracking <5ms, Context loader <200ms
- Test performance impact of each hook
- Make hooks **easily toggleable** (config.json enabled flags)
- Maintain **backwards compatibility** (don't break existing workflows)
- **Document everything** so future you can maintain it
- Use **async/batch logging** to minimize overhead
- Apply **size limits** to prevent context bloat

---

## Summary of Enhancements

This updated plan includes:

âœ… **Optimization improvements:**
- Screenshot: Crop, resize, compress, deduplicate (95%+ size reduction)
- Tool tracking: Async/batch logging (<5ms overhead)
- Context loader: Size limits (500 lines / 50KB max)

âœ… **Feature enhancements:**
- TODO extractor: Priority detection (critical/high/normal)
- Auto test runner: Smart scope control (related tests only)
- UV enforcement: Escape hatch for special cases
- Session end TTS: Outcome-based messages (success/error/long session)
- rm -rf protection: Audit logging
- Commit messages: Removed Co-Authored-By line

âœ… **Performance strategy:**
- Async logging with background threads
- Batch writes for high-frequency events
- Database indexing for fast queries
- Configurable thresholds and toggles

âœ… **Decisions made:**
- Two separate TODO files (manual + auto-generated)
- Track ALL tools, not just Bash
- Auto-push: Skip main/master unless only branch
- Context files: Apply size limits to prevent bloat

---

*Ideas captured and optimized: 2025-11-13*
*Ready for high-performance implementation! Let's build some awesome hooks! ðŸš€*
